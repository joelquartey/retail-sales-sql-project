/*
    CUMULATIVE TABLE DESIGN
    ************************************

    Cumulative Table Design in data modeling is a table structure used to store precomputed aggregated/summarized data (SUM, COUNT, AVG)
    over a period of time, allowing for efficient trend analysis, totals or progressions. These tables are updated periodically to reflect
    cumulative values for metrics of interest.

    It is efficient for fast retrieval of precomputed results, avoiding expensive aggregations at query time and reducing load on transactional tables.
    It is mostly used for growth analysis over time. It's all about holding onto all of history

    Advantages:
    - Ability to do historical analysis without shuffle (Without GROUP BY)
    - Easy 'transition' analysis

    Drawbacks: It can only be backfilled sequentially.


    Pictorial View of Cumulative Table Design:
    -------------------------------------------------------

    1. Get Yesterday(day, month or year) + Today(day, month or year)
    2. Perform:
        - FULL OUTER JOIN
        - COALESCE ids and unchanging dimensions
        - Compute cumulative metrics
    3. Cumulated Output



    For our project, the metrics of interest are:
    - Sales Performance Tracking
    - Market Trend Analysis
    - Customer Segmentation

*/





-- Create a schema to house all OLAP tables
CREATE SCHEMA RetailSalesDW;

-- change schema to dataWarehouse
SET search_path TO schema_name, RetailSalesDW;




/*
    Product Sales Performance
    --------------------------------------
    To monitor cumulative sales performance of each product category by day

    *** seed query for cumulation is the first backfill
 */
CREATE TABLE cum_product_sales(
    category_id INT,
    product_category TEXT,
    cumulative_quantity INT,
    cumulative_sales NUMERIC(18, 2),
    present_date DATE,
    PRIMARY KEY (category_id, present_date)
);



-- Check the first ever date in the table
SELECT MIN(invoice_date), MAX(invoice_date) from retailsales.sales_details;



/*
    ETL pipeline to:
    - Extract the two dataset (yesterday and today)
    - Transform the dataset by combining both datasets using a FULL OUTER JOIN
    - Load into the target table: cum_product_sales

    Since we will be backfilling on a daily basis, we need to toggle only the present_date with yesterday's date and today's date
    Note: that the first time we run this pipeline/query which is our seed query will yield only "today's" data only,
    i.e the first date: 2023-01-01 as today's date and 2022-12-31 as yesterday's date.
*/

INSERT INTO cum_product_sales (category_id, product_category, cumulative_quantity, cumulative_sales, present_date)
WITH yesterday AS (
    -- Get previous day's cumulative values
    SELECT * FROM cum_product_sales
    WHERE present_date = '2023-01-04'
),
today AS (
    -- Compute today's sales per category
    SELECT
        t1.category_id,
        t2.category AS product_category,
        SUM(t1.quantity) AS cumulative_quantity,
        SUM(t1.amount) AS cumulative_sales,
        t1.invoice_date AS present_date
    FROM retailsales.sales_details t1
    LEFT JOIN retailsales.product_category t2 ON t1.category_id = t2.category_id
    WHERE t1.invoice_date = '2023-01-05'
    GROUP BY t1.category_id, t2.category, t1.invoice_date
)
SELECT
    COALESCE(t.category_id, y.category_id) AS category_id,
    COALESCE(t.product_category, y.product_category) AS product_category,
    -- Accumulate quantity and sales from yesterday and today
    COALESCE(y.cumulative_quantity, 0) + COALESCE(t.cumulative_quantity, 0) AS cumulative_quantity,
    COALESCE(y.cumulative_sales, 0) + COALESCE(t.cumulative_sales, 0) AS cumulative_sales,
    -- Always take today's date for new entries
    t.present_date AS present_date
FROM today t
FULL OUTER JOIN yesterday y ON t.category_id = y.category_id;



TRUNCATE TABLE cum_product_sales;
SELECT * FROM cum_product_sales;

SELECT * FROM cum_product_sales
WHERE product_category='Electronics';










/*
    Customer Location/Region Sales Metrics
    -----------------------------------------
    Will contain aggregated sales data across customer locations/regions by (day/month/year)
 */
CREATE TABLE cum_region_sales(

);



/*
    Customer Product Engagement
    -------------------------------------------
    To track how often customers buy certain product
 */
CREATE TABLE cum_customer_product_engage(

);



/*
    Customer Lifetime Value (CLV)
    --------------------------------------------
    This will help us track the total revenue generated by each customer
 */
CREATE TABLE cum_customer_revenue_value(

);



/*
    Modeling complex data types using STRUCT and ARRAYS
    ***********************************************************

    Customer Purchase History with detailed transactions
    ---------------------------------------------------------

    This will help us model a MASTER DATA with complex data types which could be used by other Data Engineers. This will serve us a
    single source of truth for Data Engineers.
 */



SELECT customer_id, COUNT(customer_id) num_recs
FROM sales_details
GROUP BY customer_id
ORDER BY num_recs DESC;


select count(*) from customer;
select * from sales_details;